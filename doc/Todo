1. add UserMode(Customer,Agent,Seller,Admin),IsLive&SockID to User [agent record], limit one mode with one mob_no
------------------------------------------------------
TransitCompletedByAgent [ Rating/ Issue Reporting] [TODO Set an API to handle issue reporting ]
----------------------------------------------------------
Create a transit history array with {Time: enitity:action}
----------------------------------------------------------
add item count in api itself
----------------------------------------------------------
    gstcategory: product1.gstcategory,
    warrentycard: product1.warrentycard,
    extradiscount: product1.extradiscount,
    productdescription: product1.productdescription,
    productdetails: product1.productdetails,
----------------------------------------------------------
User registration has to set manual [capcha/passwd-retry(latency/blocking)]
Find faults comes form public data [feed& get queries]
----------------------------------------------------------
// User/Shop can be targeted with flood of approval requests.
----------------------------------------------------------
Condition the limit of how many staff a store can have
a staff can part of how many stores 
convert approved/pending/accepted lists in to map
----------------------------------------------------------
need to store history of action of users [eg: accepted invitaion/ denied...]
----------------------------------------------------------
when a product get deleted what to do for its associated journals
----------------------------------------------------------
check if one of the socket id is not present at the time of emission, how system crashes
----------------------------------------------------------
for duplicate notifications reject the same in frond end
----------------------------------------------------------
if (ctxt.Delay() > ctxt.MaxWT)
{
	console.log('order-delay-exceeded', ctxt)
	const msg = 
	{		 
		To	: [...ctxt.Store.SockID, ...ctxt.User.SockID],
		Msg	:
		{
			Type: alerts.AutoCancelled,
			Data: ctxt.Abstract(entity.Agent)
		}
	}
	Emit(msg)
	ctxt.State 		= states.TransitRejected
	ctxt.Event 		= ""
	ctxt.Save()
	return
}

/* not for now
   validate reason for rejection + take necessary actions
   increment fault count of current agent agent */ 
case states.TransitAccepted:
	/* Logic to be streamlined :
	0) Not for now: Handle reason for rejection/ agent fault rating index/ admin actions if any 
	1) How to cutoff if a agent intentionally delays an order with repeatetion accept/reapeat
	2) How to handle if accept /reject loop grows beyond a expected time */
----------------------------------------------------------
// TODO { Add Journal ID to the cart & remove it only after payment success }
----------------------------------------------------------
Check paytm token are stored at server or not
----------------------------------------------------------
	// Fraud Alert if for incorrect OTP
----------------------------------------------------------
TransitIgnoredByAgent
// This event can come from mutiple agent.
// If waiting time goes beyond 7min auto cancel the order
----------------------------------------------------------
const OrderAcceptanceTimeout		= async function(ctxt)
{
	// Create a machine call to this function from init API
	// after saving the context setting event as timeout

	//  Generate automated voice alert(repeat thrice if no user action)
	// If admin does not initiate explicitly action, 
	// auto reject the order & refund [May be a different event]
}
----------------------------------------------------------
const TransitRejectedByAgent		= async function(ctxt)
{
	switch(ctxt.State)
	{
	case states.TransitAccepted:
/* Logic to be streamlined :
	0) Not for now: Handle reason for rejection/ agent fault rating index/ admin actions if any 
	1) How to cutoff if a agent intentionally delays an order with repeatetion accept/reapeat
	2) How to handle if accept /reject loop grows beyond a expected time */
			const agent = new User()
			const agents = agent.ListNearbyLiveAgents(ctxt.Store.Location)
			if(!agents)
			{
				// Notify admin about the absents of live agents
				console.log('no-nearby-agents-order-on-hold', ctxt)
				await Emit(alerts.NoAgents, ctxt)
				await Save(ctxt, states.OrderOnHold)
				return
			}
			await Emit(alerts.NewTransit, ctxt)
	case states.OrderDespatched:
	/**
	 * Generate new notification to agent with
	 * location as of current agent location
	 * notify admin to track furthur progress
	 */

	}
	delete ctxt.Agent
	await Save(ctxt, states.TransitRejected)
}
----------------------------------------------------------
at read_otp : there is a race condition
limit devices / socket connections
lock cart checkout once the payment initated
Beware do not modify current and previous state before payout
----------------------------------------------------------
01 journal read											21/08/12
02 ground one mob no for one mode [ for now ]
03 journal	list	agetn/store/user/admin
04 product list limit
05 product add  variant
06 store   list limit
07 store   edit
08 store   delete
09 staff   list limit
10 search & product filtering with tree tags
11 set token in cookies
12 root admin + sub admin logics
13 https
14 input validator (Task as mdatory field)
15 bug : for immediate connectivity trigger a rest request after socket connection
16 socket limit connections
17 db geo indexing, filtering enahcement
18 generic api for otp resend in all scenarios [user{profile/reg/login}/cart/shop | product/addr/payment/transit]
19 google map distance
20 provision for forceful app update
21 IMPORTANT: remove printing user password hashes from logs
22 reinforce bill
23 no deletion of records, only unlisting of the data [ if it has used at someother critical point ]
24 jwt - set timestamp and expire the token - why sperate token for partially registered user
25 load pricing context from db on system start and set an api to update it (on db + on cache)