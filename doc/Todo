04 store   edit
05 store   delete

11 set token in resp header
13 https
14 input validator (Task as mdatory field)
16 socket limit connections

17 db geo indexing, filtering enahcement
18 generic api for otp resend in all scenarios [user{profile/reg/login}/cart/shop | product/addr/payment/transit]
19 google map distance

20 search & product filtering with tree tags
22 reinforce bill

23 no deletion of records, only unlisting of the data [ if it has used at someother critical point ] [ when a product get deleted what to do for its associated journals ]
24 jwt - set timestamp and expire the token - why sperate token for partially registered user

29 Modify a transit history array with {Time: enitity:action }

35 at read_otp : there is a race condition
36 limit devices / socket connections
37 - lock cart checkout once the payment initated 
   - Add Journal ID to the cart & remove it only after payment success - limit number of checkouts in given span of time [This will be a good algorithm ]
38 TransitIgnoredByAgent - on admin lock, if waiting time exceeds limits, tigger another handler to auto cancel
40 Clear quoted TODOs
12 root admin + sub admin logics
15 bug : for immediate connectivity trigger a rest request after socket connection



Low priority:
03 product add  variant

28 TransitCompletedByAgent [ Rating / Issue Reporting ] [TODO Set an API to handle issue reporting ]

21 IMPORTANT: remove printing user password hashes from logs
31 User registration has to set manual [capcha/passwd-retry(latency/blocking)] && User/Shop can be targeted with flood of approval requests.
27 Check if paytm keeps a context of token, is there a way to reuse it - how to handle double checkout in current scenario
25 load pricing context from db on system start and set an api to update it (on db + on cache)
* need to store history of action of users [eg: accepted invitaion/ denied...]

Test
02 journal	list admin